
/**************************************************************
 *
 * - CeCILL-B license
 * - (bsd-like, check http://www.cecill.info/faq.en.html#bsd)
 * 
 * Copyright CNRS
 * Contributors:
 * David Gauchard <gauchard@laas.fr>	2013-01-01
 * 
 * This software is a computer program whose purpose is to
 * provide a "Graphical Access To Exterior" (GATE).  The goal
 * is to provide a generic GUI, within a javascript web
 * browser, through a TCP network using the websocket protocol. 
 * Plain text protocol (simple human readable graphic commands)
 * translators to websockets protocol are also provided to
 * connect user applications to the browser via a C library or
 * simple TCP server.
 * 
 * This software is governed by the CeCILL-B license under
 * French law and abiding by the rules of distribution of free
 * software.  You can use, modify and/ or redistribute the
 * software under the terms of the CeCILL-B license as
 * circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 * 
 * As a counterpart to the access to the source code and rights
 * to copy, modify and redistribute granted by the license,
 * users are provided only with a limited warranty and the
 * software's author, the holder of the economic rights, and
 * the successive licensors have only limited liability.
 * 
 * In this respect, the user's attention is drawn to the risks
 * associated with loading, using, modifying and/or developing
 * or reproducing the software by the user in light of its
 * specific status of free software, that may mean that it is
 * complicated to manipulate, and that also therefore means
 * that it is reserved for developers and experienced
 * professionals having in-depth computer knowledge.  Users are
 * therefore encouraged to load and test the software's
 * suitability as regards their requirements in conditions
 * enabling the security of their systems and/or data to be
 * ensured and, more generally, to use and operate it in the
 * same conditions as regards security.
 * 
 * The fact that you are presently reading this means that you
 * have had knowledge of the CeCILL-B license and that you
 * accept its terms.
 * 
 *************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <sys/stat.h>

#include <assert.h>
#include <zlib.h>

#define LEN		1024
#define BIGLEN		32768
#define CHUNKIN		262144
#define CHUNKOUT	1024
unsigned char in [CHUNKIN];
unsigned char out [CHUNKOUT];
        

#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
#  include <fcntl.h>
#  include <io.h>
#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
#  define snprintf(a,b,c...) sprintf(a,c)
#else
#  define SET_BINARY_MODE(file)
#endif

void help (const char* name)
{
	printf( "synopsis:\n"
		"	%s <file-basename> <struct-name> <filename>[,u] [<filename>[,u]...]\n"
		"\n"
		"description:\n"
		"	This tool will produce a filename '<file-basename>.h'\n"
		"	which defines a structure called binware_s, and an extern\n"
		"	variable of this type called 'binware_<struct-name>'.\n"
		"	It will then make '<file-basename>.c' which contains\n"
		"	zlib-compressed C-ified <filename>s (or uncompressed if\n"
		"	file name is suffixed by ,u).\n"
		"	The structure 'binware_<struct-name>' is finally\n"
		"	declared for indexing.\n"
		"\n"
		, name);
}

void build_defname (char* defname, const char* filename)
{
	int i;
	char c;
	i = 0;
	do
	{
		switch (c = filename[i])
		{
			case '.':
			case '-':
			case '/':
				c = '_';
				break;
		}
		defname[i++] = c;
	} while (c);
	defname[i] = c;
}
		
char binname[LEN], temp[LEN], decl[BIGLEN];

int main (int argc, const char* argv[])
{
	FILE* f;
	FILE* fc;
	FILE* fh;
	const char* filename;
	const char* basehname;
	const char* headername;
	off_t size, csize, i, linesize;
	int nf;
	
	if (argc < 4)
	{
		help(argv[0]);
		return 1;
	}
	
	filename = argv[1];
	
	/*
	 * builds basehname and fhname as of 'unix basename' of filename
	 * (for the #include)
	 */
	for (basehname = &filename[strlen(filename) - 1]; basehname != filename && *basehname != '/'; basehname--);
	if (basehname != filename)
		basehname++;

	snprintf(temp, LEN, "%s.h", filename);
	

	/*
	 * build .h file
	 */

	if ((fh = fopen(temp, "w")) == NULL)
	{
		perror(temp);
		return 1;
	}

	fprintf(fh, "/* This file is automatically generated */\n"
		    "\n"
		    "#ifndef __BINWARE_H__\n"
		    "#define __BINWARE_H__\n"
		    "\n"
		    "#ifdef __cplusplus\n"
		    "extern \"C\"\n"
		    "{\n"
		    "#endif /* __cplusplus */\n"
		    "\n"
		    "typedef struct\n" "{\n"
		    "\tconst char*\t\tname;\n"
		    "\tunsigned long\t\tsize;\n"
		    "\tunsigned long\t\tcompressed_size;\n"
		    "\tconst unsigned char*\tdata;\n"
		    "} binware_s;\n"
		    "\n"
		    "#ifdef __cplusplus\n"
		    "} /* extern \"C\" */\n"
		    "#endif /* __cplusplus */\n"
		    "\n");
	
	headername = argv[2];
	build_defname(temp, headername);
	fprintf(fh, "extern const binware_s binware_%s [];\n\n"
		    "#endif // __BINWARE_H__\n\n"
	            , temp);
	fclose(fh);
	
	/*
	 * now the .c file
	 */

	decl[BIGLEN - 1] = 255;
	snprintf(decl, BIGLEN, "const binware_s binware_%s [] =\n{", temp);

	snprintf(temp, LEN, "%s.c", filename);
	if ((fc = fopen(temp, "w")) == NULL)
	{
		perror(temp);
		return 1;
	}
	fprintf(fc, "/* This file is automatically generated */\n"
		    "\n"
		    "#include \"%s.h\"\n"
		    "\n",
		    basehname);

	for (nf = 3; nf < argc; nf++)
	{
		int ret, zflush, have;
		char defname[LEN];
		size_t nlen;
		int z = 1; // compressme
        
		strcpy(binname, argv[nf]);
		nlen = strlen(binname);
		if (   nlen > 2
		    && binname[nlen - 1] == 'u'
		    && binname[nlen - 2] == ',')
		{
			z = 0; // no compression
			binname[nlen - 2] = 0;
		}

		build_defname(defname, binname);
		printf("processing '%s' (%s)\n", binname, z? "deflate": "store");
		
		if ((f = fopen(binname, "rb")) == NULL)
		{
			fprintf(stderr, "skipping '%s' (%s)\n", binname, strerror(errno));
			continue;
		}
		
		size = 0;
		linesize = 0;
		fprintf(fc, "static const unsigned char %s[] =\n{\t", defname);

	if (z)
	{
		z_stream strm;

		/* allocate deflate state */
		strm.zalloc = Z_NULL;
		strm.zfree = Z_NULL;
		strm.opaque = Z_NULL;
		ret = deflateInit(&strm, Z_BEST_COMPRESSION);
		if (ret != Z_OK)
		{
			fprintf(stderr, "zlib error\n");
			return ret;
		}
		
		csize = 0;

		/* compress until end of file */
		do
		{
			size += strm.avail_in = fread(in, 1, CHUNKIN, f);
			if (ferror(f))
			{
				(void)deflateEnd(&strm);
				fprintf(stderr, "%s (error %i)\n", strm.msg, Z_ERRNO);
				return 1;
			}
			zflush = feof(f) ? Z_FINISH : Z_NO_FLUSH;
			strm.next_in = in;
			/* run deflate() on input until output buffer not full, finish
			   compression if all of source has been read in */
			do
			{
				strm.avail_out = CHUNKOUT;
				strm.next_out = out;
				ret = deflate(&strm, zflush);	/* no bad return value */
				assert(ret != Z_STREAM_ERROR);	/* state not clobbered */

				have = CHUNKOUT - strm.avail_out;
				for (i = 0; i < have; i++)
				{
					linesize += fprintf(fc, "%i,", (unsigned char)out[i]);
					if (!(strm.avail_out != 0 && zflush == Z_FINISH && i == have - 1) && linesize > 65)
					{
						fprintf(fc, "\n\t");
						linesize = 0;
					}
				}
				csize += have;
				
			} while (strm.avail_out == 0);

			/* done when last data in file processed */
		} while (zflush != Z_FINISH);
		
		assert(ret == Z_STREAM_END);	/* stream will be complete */
		assert(strm.avail_in == 0);	/* all input will be used */
		/* clean up and return */
		(void)deflateEnd(&strm);

		fprintf(fc, "\n};\n#define %s_LEN %i\n", defname, (int)size);
		fprintf(fc, "#define %s_CLEN %i\n\n", defname, (int)csize);
	}
	else
	{
		size_t chunk;
		do
		{
			size_t c;
			chunk = fread(in, 1, CHUNKIN, f);
			size += chunk;
			if (ferror(f))
			{
				fprintf(stderr, "%s: error reading\n", binname);
				return 1;
			}
			for (c = 0; c < chunk; c++)
			{
				linesize += fprintf(fc, "%i,", (unsigned char)in[c]);
				if (!(chunk < CHUNKIN && c == chunk - 1) && linesize > 65)
				{
					fprintf(fc, "\n\t");
					linesize = 0;
				}
			}
		} while (chunk == CHUNKIN);

		fprintf(fc, "\n};\n#define %s_LEN %i\n", defname, (int)size);
		fprintf(fc, "#define %s_CLEN %i\n\n", defname, 0);
	}
	
		fclose(f);
	
		if (snprintf(temp, LEN, "\t{ \"%s\", %s_LEN, %s_CLEN, %s },\n", binname, defname, defname, defname) == LEN)
		{
			fprintf(stderr, "please increase LEN\n");
			return 1;
		}

		decl[BIGLEN - 1] = 255;
		strncat(decl, temp, BIGLEN - 1 - strlen(decl));
		if (!decl[BIGLEN - 1])
		{
			fprintf(stderr, "please increase BIGLEN\n");
			return 1;
		}
	}
	fprintf(fc, "%s", decl);
	fprintf(fc, "\t{ /*NULL*/0L, 0, 0, /*NULL*/0L }\n};\n\n");

	fclose(fc);

	return 0;
}
